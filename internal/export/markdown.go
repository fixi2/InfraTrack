package export

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/fixi2/InfraTrack/internal/store"
)

var nonSlugChars = regexp.MustCompile(`[^a-z0-9]+`)

func WriteMarkdown(session *store.Session, workingDir string) (string, error) {
	runbooksDir := filepath.Join(workingDir, "runbooks")
	if err := os.MkdirAll(runbooksDir, 0o755); err != nil {
		return "", fmt.Errorf("create runbooks directory: %w", err)
	}

	filename := RunbookFilename(session)
	outputPath := filepath.Join(runbooksDir, filename)

	body := RenderMarkdown(session)
	if err := os.WriteFile(outputPath, []byte(body), 0o644); err != nil {
		return "", fmt.Errorf("write markdown file: %w", err)
	}

	return outputPath, nil
}

func RunbookFilename(session *store.Session) string {
	ts := session.StartedAt.UTC().Format("20060102-150405")
	slug := slugify(session.Title)
	return fmt.Sprintf("%s-%s.md", ts, slug)
}

func RenderMarkdown(session *store.Session) string {
	var b strings.Builder

	b.WriteString("# ")
	b.WriteString(session.Title)
	b.WriteString("\n\n")

	b.WriteString("## Summary\n")
	b.WriteString("This runbook was generated from an explicit InfraTrack session.\n")
	b.WriteString(fmt.Sprintf("Recorded %d step(s).\n\n", len(session.Steps)))

	b.WriteString("## Preconditions\n")
	b.WriteString("- TODO: Verify required tools and access are available.\n")
	b.WriteString("- TODO: Confirm no secrets are needed in commands.\n\n")

	b.WriteString("## Steps\n")
	if len(session.Steps) == 0 {
		b.WriteString("1. TODO: No recorded steps.\n\n")
		b.WriteString("```sh\n")
		b.WriteString("# TODO: add command\n")
		b.WriteString("```\n\n")
	} else {
		for i, step := range session.Steps {
			status, reason := normalizeResult(step)
			b.WriteString(fmt.Sprintf("%d. Execute command\n\n", i+1))
			b.WriteString("```sh\n")
			b.WriteString(step.Command)
			b.WriteString("\n```\n")
			b.WriteString(fmt.Sprintf("Result: %s", status))
			if reason != "" {
				b.WriteString(fmt.Sprintf(" (%s)", reason))
			}
			b.WriteString("\n")
			if step.ExitCode != nil {
				b.WriteString(fmt.Sprintf("Exit code: %d\n", *step.ExitCode))
			}
			b.WriteString(fmt.Sprintf("Duration: %d ms\n\n", step.DurationMS))
		}
	}

	b.WriteString("## Verification\n")
	b.WriteString("- [ ] TODO: Define verification checks.\n\n")

	b.WriteString("## Rollback\n")
	b.WriteString("- TODO: Add rollback commands.\n\n")

	b.WriteString("## Notes\n")
	b.WriteString("- Generated by InfraTrack MVP v0.1.\n")

	return b.String()
}

func normalizeResult(step store.Step) (string, string) {
	status := step.Status
	reason := step.Reason

	if status == "" {
		if step.ExitCode == nil {
			return "UNKNOWN", "unknown"
		}
		if *step.ExitCode == 0 {
			return "OK", ""
		}
		return "FAILED", "nonzero_exit"
	}

	if status == "FAILED" && reason == "" && step.ExitCode != nil && *step.ExitCode != 0 {
		reason = "nonzero_exit"
	}
	if status == "REDACTED" && reason == "" {
		reason = "policy_redacted"
	}

	return status, reason
}

func slugify(title string) string {
	slug := strings.ToLower(strings.TrimSpace(title))
	slug = nonSlugChars.ReplaceAllString(slug, "-")
	slug = strings.Trim(slug, "-")
	if slug == "" {
		return "runbook"
	}
	return slug
}
